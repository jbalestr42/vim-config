#include "Tree.hpp"
#include "Map/Map.hpp"
#include "DefineResources.hpp"
#include "Octo/OctoLogger.hpp"

Tree::Tree(void) :
	StaticObject(),
	mn_countAngle(0u),
	mf_timer(0.0f),
	mb_growSide(false),
	mb_isLeaf(false)
{
	// Number of square in pythagoras trees
	mn_maxRectangle = pow(2, DEPTH) - 1;
	// Squares divided in triangles + link triangles
	mn_maxTriangle = mn_maxRectangle * 3;
	mn_maxLeaf = pow(2, DEPTH - 1) - 1;

	m_triangle.reset(new sf::Vertex[mn_maxTriangle * 3u + mn_maxLeaf * 6u]);
	m_refAngle.resize(mn_maxRectangle);
}

Tree::~Tree(void)
{
	m_refAngle.clear();
}

void Tree::pythagorasTree(sf::Vector2f p_center, sf::Vector2f p_size, float pf_angle, float pf_cos, float pf_sin, const int pn_depth)
{
	if (pn_depth == 1)
	{
		mn_countLeaf = mn_countAngle = 0;
		mn_countTriangle = (mn_maxLeaf + 1) * 6u;
	}

	// Get seed angle
	float refAngle;
	if (mb_growSide)
		refAngle = m_refAngle[mn_countAngle] * mf_mouvement;
	else
		refAngle = 90.f - m_refAngle[mn_countAngle] * mf_mouvement;
	mn_countAngle++;

	// Init color
	float colorChange = pn_depth * 15;
	sf::Color color = sf::Color(m_color.r + colorChange, m_color.g + colorChange, m_color.b + colorChange);

	// Create extended root
	if (pn_depth == 1)
	{
		createVertex(sf::Vector2f(p_center.x - p_size.x / 2, p_center.y + p_size.y / 2), color, &mn_countTriangle);
		createVertex(sf::Vector2f(p_center.x + p_size.x / 2, p_center.y + p_size.y / 2), color, &mn_countTriangle);
		createVertex(sf::Vector2f(p_center.x + p_size.x / 2, SIZE_SCREEN_Y), color, &mn_countTriangle);
		createVertex(sf::Vector2f(p_center.x - p_size.x / 2, p_center.y + p_size.y / 2), color, &mn_countTriangle);
		createVertex(sf::Vector2f(p_center.x + p_size.x / 2, SIZE_SCREEN_Y), color, &mn_countTriangle);
		createVertex(sf::Vector2f(p_center.x - p_size.x / 2, SIZE_SCREEN_Y), color, &mn_countTriangle);
	}

	// Create root rectangle
	sf::Vector2f leftUpRoot;
	sf::Vector2f rightUpRoot;
	createRectangle(p_center, p_size, color, 5, &mn_countTriangle, pf_cos, pf_sin, &leftUpRoot, &rightUpRoot);

	// Stop recursion
	if (pn_depth >= DEPTH)
		return;

	// Compute left branch
	float rectangleAngleLeft = pf_angle - refAngle;
	float radianLeft = rectangleAngleLeft * PI / 180.f;
	float cosLeft = cos(radianLeft);
	float sinLeft = sin(radianLeft);

	float leftSizeX = cos(refAngle * RADIAN) * p_size.x;
	float leftSizeY = leftSizeX * p_size.y / p_size.x;
	leftSizeY *= mf_mouvement;
	sf::Vector2f leftSize(leftSizeX, leftSizeY);
	sf::Vector2f leftCenter(leftSize.x / 2.f, -leftSize.y / 2.f);
	rotateVec(&leftCenter, cosLeft, sinLeft);
	leftCenter += p_center + leftUpRoot;

	// Compute right branch
	float rectangleAngleRight = pf_angle + 90.f - refAngle;
	float radianRight = rectangleAngleRight * PI / 180.f;
	float cosRight = cos(radianRight);
	float sinRight = sin(radianRight);

	float rightSizeX = cos((90.0f - refAngle) * RADIAN) * p_size.x;
	float rightSizeY = (rightSizeX * p_size.y / p_size.x);
	rightSizeY *= mf_mouvement;
	sf::Vector2f rightSize(rightSizeX, rightSizeY);
	sf::Vector2f rightCenter(-rightSize.x / 2.f, -rightSize.y / 2.f);
	rotateVec(&rightCenter, cosRight, sinRight);
	rightCenter += p_center + rightUpRoot;

	// Create leaf
	if (pn_depth == DEPTH - 1 && mb_isLeaf)
	{
		float size = (m_size.y * refAngle / (MAX_A - MIN_A)) * mf_mouvement;
		createRectangle(rightCenter, sf::Vector2f(size, size), m_leafColor, 5, &mn_countLeaf, cosRight, sinRight);
		createRectangle(leftCenter, sf::Vector2f(size, size), m_leafColor, 5, &mn_countLeaf, cosLeft, sinLeft);
	}

	// Left recursion
	pythagorasTree(leftCenter, leftSize, rectangleAngleLeft, cosLeft, sinLeft, pn_depth + 1);

	color += sf::Color(10, 10, 10);
	// Fill empty space with triangle
	createVertex(rightUpRoot + p_center, color, &mn_countTriangle);
	createVertex(leftUpRoot + p_center, color, &mn_countTriangle);
	// Get upTriangle in m_rectangle
	sf::Vector2f upTriangle(-rightSize.x, 0.f);
	rotateVec(&upTriangle, cosRight, sinRight);
	createVertex(upTriangle + p_center + rightUpRoot, color, &mn_countTriangle);

	// Right recusrion
	pythagorasTree(rightCenter, rightSize, rectangleAngleRight, cosRight, sinRight, pn_depth + 1);

}

void Tree::randomTree(void)
{
	me_currentState = e_treeState_grow;
	mb_growSide = static_cast<bool>(rand() % 2);
	mb_isLeaf = m_biome->mn_temperature >= 0 ? true : false;

	//m_color = sf::Color(randomRange(20, 200), randomRange(20, 200), randomRange(20, 200));
	m_color = sf::Color(180.f, 33.f, 85.f);
	m_leafColor = sf::Color(212.f, 185.f, 39.f);
	float tmpX = randomRangeTile(static_cast<int>(10000.f / m_biome->mn_height), static_cast<int>(13000.f / m_biome->mn_height));
	float tmpY = randomRange(m_biome->mn_height / 2.0f, m_biome->mn_height);
	m_size = sf::Vector2f(tmpX, tmpY);

	for (int i = 0; i < mn_maxRectangle; i++)
	{
		/*
		// test sapin
		if (i == 0 || i == pow(2, DEPTH - 2) + 1 || i == pow(2, DEPTH - 2) + 1 + pow(2, DEPTH - 3))
			m_refAngle[i] = randomRange(15, 25);
		else if (i == 1 || i == pow(2, DEPTH - 2) + 2 || i == 23)
			m_refAngle[i] = randomRange(75, 85);
		else
		*/
			m_refAngle[i] = randomRange(MIN_A, MAX_A);
	}
	mf_mouvement = 0.00f;
	pythagorasTree(m_origin, m_size);
}

void Tree::init(Biome * p_biome)
{
	StaticObject::init(p_biome);

	randomTree();
}

void Tree::update(float pf_deltatime)
{
	StaticObject::update(pf_deltatime);

	mf_timer += pf_deltatime;
	if (mf_timer > 4.0f)
		mf_timer = 0.0f;
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::P))
		randomTree();
	if (me_currentState == e_treeState_grow)
	{
		mf_mouvement += pf_deltatime / 4;
		if (mf_mouvement >= 1.0f)
		{
			mf_timer = 0.0f;
			me_currentState = e_treeState_sleep;
		}
	}
	else if (me_currentState == e_treeState_sleep)
	{
		if (mf_timer > 2.0f)
			mf_mouvement += pf_deltatime / (20 + (mf_timer - 2.0f) * 10);
		else
			mf_mouvement -= pf_deltatime / (20 + mf_timer * 10);
	}
	float delta = (m_size.y - m_size.y * mf_mouvement) / 2;
	pythagorasTree(sf::Vector2f(m_origin.x, m_origin.y + delta), sf::Vector2f(m_size.x, m_size.y * mf_mouvement));
}
