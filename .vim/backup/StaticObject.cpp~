#include "StaticObject.hpp"
#include "Main/ResourcesManager.hpp"
#include "Map/Map.hpp"
#include <cmath>

StaticObject::StaticObject(void) :
	GameObject(300.f, 500.f, nullptr),
	me_currentState(e_treeState_sleep),
	m_size(50.0f, 50.0f),
	m_color(sf::Color(0, 0, 0)),
	mn_countTriangle(0u)
{
	//TODO: put it somewhere else
	srand(time(NULL));
}

StaticObject::~StaticObject(void)
{
}

void StaticObject::rotateVec(sf::Vector2f *p_point, float p_cosAngle, float p_sinAngle)
{
	sf::Vector2f tmp;
	tmp.x = p_point->x * p_cosAngle - p_point->y * p_sinAngle;
	tmp.y = p_point->y * p_cosAngle + p_point->x * p_sinAngle;
	*p_point = tmp;
}

float StaticObject::randomRange(int pn_min, int pn_max)
{
	return static_cast<float>(random() % (pn_max - pn_min) + pn_min);
}

float StaticObject::randomRangeTile(int pn_min, int pn_max)
{
	int tmp = randomRange(pn_min, pn_max);
	tmp -= tmp % 16;
	return static_cast<float>(tmp);
}

void StaticObject::createVertex(sf::Vector2f p_pos, sf::Color const & p_color, int * pn_count)
{
	m_triangle[*pn_count].position = p_pos;
	m_triangle[*pn_count].color = p_color;
	(*pn_count)++;
}

void StaticObject::createRectangle(sf::Vector2f const & p_center, sf::Vector2f const & p_size, sf::Color & p_color, float p_valueColor, int * pn_count, float pf_cos, float pf_sin, sf::Vector2f * p_leftUp, sf::Vector2f * p_rightUp)
{
	float x = p_size.x / 2.0f;
	float y = p_size.y / 2.0f;

	sf::Vector2f leftDown(-x, y);
	sf::Vector2f leftUp(-x, -y);
	sf::Vector2f rightDown(x, y);
	sf::Vector2f rightUp(x, -y);

	rotateVec(&leftDown, pf_cos, pf_sin);
	rotateVec(&leftUp, pf_cos, pf_sin);
	rotateVec(&rightDown, pf_cos, pf_sin);
	rotateVec(&rightUp, pf_cos, pf_sin);

	// Create rectangle (2 triangles)
	createVertex(rightUp + p_center, p_color, pn_count);
	createVertex(rightDown + p_center, p_color, pn_count);
	createVertex(leftDown + p_center, p_color, pn_count);
	p_color += sf::Color(p_valueColor, p_valueColor, p_valueColor);
	createVertex(leftDown + p_center, p_color, pn_count);
	createVertex(leftUp + p_center, p_color, pn_count);
	createVertex(rightUp + p_center, p_color, pn_count);

	if (p_leftUp)
		*p_leftUp = leftUp;
	if (p_rightUp)
		*p_rightUp = rightUp;
}

void StaticObject::init(Biome * p_biome)
{
	m_biome = p_biome;
}

void StaticObject::update(float pf_deltatime)
{
	//m_color = m_position[1].color;
	m_origin.x = m_position[0].position.x - m_size.x / 2;
	m_origin.y = m_position[0].position.y - m_size.y / 2;
}

void StaticObject::draw(sf::RenderTarget& p_target, sf::RenderStates p_states) const
{
	p_target.draw(m_triangle.get(), mn_countTriangle, sf::Triangles, p_states);
}
