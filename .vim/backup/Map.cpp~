#include "Map.hpp"
#include "Octo/OctoNoise.hpp"
#include <iostream>
#include "ResourcesManager.hpp"

Map::Map(unsigned int pn_width, unsigned int pn_height) :
	mn_verticesCount(0u),
	mn_verticesCountDecor(MaxDecor * 4u),
	mn_decorTileCount(0u),
	mf_depth(0.f),
	mf_oldDepth(0.f),
	mn_totalWidth(0),
	mn_offsetX(0),
	mn_offsetY(0)
{
	debug.setFont(ResourcesManager::getCurrent().getFont(FONT_CHUNKFIVE_EX));
	debug.setPosition(50.f, 500.f);
	pn_width += 3;
	pn_height += 5;
	m_tiles.resize(pn_width, pn_height, nullptr);

	m_vertices.reset(new sf::Vertex[pn_width * pn_height * 4u + mn_verticesCountDecor]);
	for (int x = 0; x < m_tiles.columns(); x++)
	{
		for (int y = 0; y < m_tiles.rows(); y++)
		{
			m_tiles(x, y) = new Tile();
			initQuad(x, y);
		}
	}
}

Map::~Map(void)
{
	for (int x = 0; x < m_tiles.columns(); x++)
	{
		for (int y = 0; y < m_tiles.rows(); y++)
			delete m_tiles(x, y);
	}
}

void Map::init(Biome * p_biome)
{
	m_biome = p_biome;
	initBiome();
}

void Map::initQuad(int x, int y)
{
	m_tiles(x, y)->mp_upLeft = &m_vertices[mn_verticesCount];

	sf::Vertex ver;
	ver.position = sf::Vector2f(x * Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[0] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize + Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[1] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize + Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[2] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[3] = ver.position;
	mn_verticesCount++;
}

void Map::computeMap(void)
{
	computeMapRange(0, m_tiles.columns(), 0, m_tiles.rows());
}

void Map::computeMapRange(int p_startX, int p_endX, int p_startY, int p_endY)
{
	float vec[3];
	int height;
	int offset;
	float v;
	// Init perlin value
	for (int x = p_startX; x < p_endX; x++)
	{
		offset = x + mn_offsetX;
		if (offset >= m_biome->mn_width)
		{
			if (offset >= mn_totalWidth)
				offset -= mn_totalWidth;
		}
		vec[0] = static_cast<float>(offset);
		vec[1] = mf_depth;
		// firstCurve return a value b/tween -1 & 1
		// we normalize it betwen 0 & max_height
		v = (firstCurve(vec) + 1.f) * static_cast<float>(m_biome->mn_height) / 2.f;
		height = static_cast<int>(v) - mn_offsetY;
		if (height < 0)
			height = 0;
		else if (height > m_tiles.rows())
			height = m_tiles.rows();
		for (int y = height; y < p_endY; y++)
		{
			vec[0] = static_cast<float>(offset);
			vec[1] = static_cast<float>(y + mn_offsetY);
			vec[2] = mf_depth;
			// secondCurve return a value between -1 & 1
			m_tiles(x, y)->mf_noiseValue = (secondCurve(vec) + 1.f) / 2.f;
			m_tiles(x, y)->mb_isEmpty = false;
			setColor(*m_tiles(x, y));
		}
		for (int y = p_startY; y < height; y++)
			m_tiles(x, y)->mb_isEmpty = true;
	}
}

void Map::computeDecor(void)
{
	float vec[3];
	float v;
	int height;
	auto it = m_decors.begin();
	for (it; it != m_decors.end(); it++)
	{
		vec[0] = static_cast<float>(it->first);
		vec[1] = mf_depth;
		v = (firstCurve(vec) + 1.f) * static_cast<float>(m_biome->mn_height) / 2.f;
		height = static_cast<int>(v);
		it->second->m_startTransition[0].y = height * Tile::TileSize + Tile::TileSize;
		vec[0] = static_cast<float>(it->first);
		vec[1] = static_cast<float>(height);
		vec[2] = mf_depth;
		it->second->mf_noiseValue = (secondCurve(vec) + 1.f) / 2.f;
		it->second->mb_isEmpty = false;
		setColor(*it->second);
	}
}

void Map::draw(sf::RenderTarget& render, sf::RenderStates states) const
{
	render.draw(m_vertices.get(), mn_verticesCount, sf::Quads, states);
	render.draw(debug);
}

void Map::addOffsetX(int p_offsetX)
{
	mn_offsetX += p_offsetX;
	if (mn_offsetX < 0)
		mn_offsetX += mn_totalWidth;
	else if (mn_offsetX >= mn_totalWidth)
		mn_offsetX -= mn_totalWidth;

	if (p_offsetX > 0)
	{
		for (int x = 0; x < m_tiles.columns() - 1; x++)
		{
			for (int y = 0; y < m_tiles.rows(); y++)
				m_tiles(x, y)->copy(*m_tiles(x + 1, y), -Tile::TileSize, 0.f);
		}
	}
	else if (p_offsetX < 0)
	{
		for (int x = m_tiles.columns() - 1; x > 0; x--)
		{
			for (int y = 0; y < m_tiles.rows(); y++)
				m_tiles(x, y)->copy(*m_tiles(x - 1, y), Tile::TileSize, 0.f);
		}
	}
}

void Map::addOffsetY(int p_offsetY)
{
	mn_offsetY += p_offsetY;

	if (p_offsetY > 0)
	{
		for (int x = 0; x < m_tiles.columns(); x++)
		{
			for (int y = 0; y < m_tiles.rows() - 1; y++)
				m_tiles(x, y)->copy(*m_tiles(x, y + 1), 0.f, -Tile::TileSize);
		}
	}
	else if (p_offsetY < 0)
	{
		for (int x = 0; x < m_tiles.columns(); x++)
		{
			for (int y = m_tiles.rows() - 1; y > 0; y--)
				m_tiles(x, y)->copy(*m_tiles(x, y - 1), 0.f, Tile::TileSize);
		}
	}
}

sf::Vertex * Map::getHeight(int x)
{
	auto it = m_decors.find(x);
	if (it == m_decors.end())
	{
		m_decors[x] = &m_reserveTile[mn_decorTileCount];
		m_decors[x]->mp_upLeft = &m_vertices[mn_verticesCount + mn_decorTileCount * 4u];
		mn_decorTileCount++;
	}
	return m_decors[x]->mp_upLeft;
}

void Map::swapDepth(void)
{
	float tmp = mf_depth;
	mf_depth = mf_oldDepth;
	mf_oldDepth = tmp;
}

void Map::registerDepth(void)
{
	mf_oldDepth = mf_depth;
}

Map::Decors & Map::getDecors(void)
{
	return m_decors;
}

unsigned int Map::getVerticeCount(void) const
{
	return mn_verticesCount;
}

unsigned int Map::getColumns(void) const
{
	return m_tiles.columns();
}

unsigned int Map::getRows(void) const
{
	return m_tiles.rows();
}

// TODO: care if decors are larger than 20*TileSize
int Map::getOffsetXDecor(int p_decorOffsetX) const
{
	int i = p_decorOffsetX - mn_offsetX;
	if (i < -20)
		return i + mn_totalWidth;
	return i;
}

int Map::getOffsetX(void) const
{
	return mn_offsetX;
}

int Map::getOffsetY(void) const
{
	return mn_offsetY;
}

Tile & Map::get(unsigned int column, unsigned int row)
{
	return *m_tiles(column, row);
}

Tile const & Map::get(unsigned int column, unsigned int row) const
{
	return *m_tiles(column, row);
}

