#include "Map.hpp"
#include "Octo/OctoNoise.hpp"

Map::Map(unsigned int pn_width, unsigned int pn_height) :
	mn_verticesCount(0u),
	mf_thirdDimension(0.f),
	mn_offsetX(0),
	mn_offsetY(0)
{
	pn_width += 3;
	pn_height += 3;
	m_tiles.resize(pn_width, pn_height, nullptr);

	m_vertices.reset(new sf::Vertex[pn_width * pn_height * 4u]);
	for (int x = 0; x < m_tiles.columns(); x++)
	{
		for (int y = 0; y < m_tiles.rows(); y++)
		{
			m_tiles(x, y) = new Tile();
			initQuad(x, y);
		}
	}
}

Map::~Map(void)
{
	for (int x = 0; x < m_tiles.columns(); x++)
	{
		for (int y = 0; y < m_tiles.rows(); y++)
			delete m_tiles(x, y);
	}
}

void Map::initQuad(int x, int y)
{
	m_tiles(x, y)->mp_upLeft = &m_vertices[mn_verticesCount];

	sf::Vertex ver;
	ver.position = sf::Vector2f(x * Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[0] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize + Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[1] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize + Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[2] = ver.position;
	mn_verticesCount++;

	ver.position = sf::Vector2f(x * Tile::TileSize, y * Tile::TileSize + Tile::TileSize);
	ver.color = sf::Color(128.f, 0.f, 128.f);
	m_vertices[mn_verticesCount] = ver;
	m_tiles(x, y)->m_startTransition[3] = ver.position;
	mn_verticesCount++;
}

void Map::computeMap(void)
{
	computeMapRange(0, m_tiles.columns(), 0, m_tiles.rows());
}

void Map::computeMapRange(int p_startX, int p_endX, int p_startY, int p_endY)
{
	float vec[3];
	int height;
	float v;
	// Init perlin value
	for (int x = p_startX; x < p_endX; x++)
	{
		vec[0] = static_cast<float>(x + mn_offsetX) / 100.0;
		vec[1] = mf_thirdDimension / 100.f;
		// firstCurve return a value b/tween -1 & 1
		// we normalize it betwen 0 & max_height
		v = (firstCurve(vec) + 1.f) * static_cast<float>(20) / 2.f;
		height = static_cast<int>(v) - mn_offsetY;
		if (height < 0)
			height = 0;
		else if (height > m_tiles.rows())
			height = m_tiles.rows();
		for (int y = height; y < p_endY; y++)
		{
			vec[0] = static_cast<float>(x + mn_offsetX) / 70.0;
			vec[1] = static_cast<float>(y + mn_offsetY) / 10.0;
			vec[2] = mf_thirdDimension / 100.f;
			// secondCurve return a value between -1 & 1
			// we normalize it between 0 & 255
			m_tiles(x, y)->mf_noiseValue = secondCurve(vec);
			m_tiles(x, y)->mn_tileType = static_cast<int>((m_tiles(x, y)->mf_noiseValue + 1.f) * 128.f);
		}
		for (int y = p_startY; y < height; y++)
			m_tiles(x, y)->mn_tileType = 0;
	}
}

float Map::firstCurve(float * vec)
{
	return OctoNoise::getCurrent().fbm(vec);
}

float Map::secondCurve(float * vec)
{
	return OctoNoise::getCurrent().noise3(vec);
}

void Map::draw(sf::RenderTarget& render, sf::RenderStates states) const
{
	//states.transform = getTransform();
	render.draw(m_vertices.get(), mn_verticesCount, sf::Quads, states);
}
void Map::addOffsetX(int p_offsetX)
{
	mn_offsetX += p_offsetX;

	if (p_offsetX > 0)
	{
		for (int x = 0; x < m_tiles.columns() - 1; x++)
		{
			for (int y = 0; y < m_tiles.rows(); y++)
				m_tiles(x, y)->copy(*m_tiles(x + 1, y), -Tile::TileSize, 0.f);
		}
		computeMapRange(m_tiles.columns() - 1, m_tiles.columns(), 0, m_tiles.rows());
	}
	else if (p_offsetX < 0)
	{
		for (int x = m_tiles.columns() - 1; x > 0; x--)
		{
			for (int y = 0; y < m_tiles.rows(); y++)
				m_tiles(x, y)->copy(*m_tiles(x - 1, y), Tile::TileSize, 0.f);
		}
		computeMapRange(0, 1, 0, m_tiles.rows());
	}
}

void Map::addOffsetY(int p_offsetY)
{
	mn_offsetY += p_offsetY;

	if (p_offsetY > 0)
	{
		for (int x = 0; x < m_tiles.columns(); x++)
		{
			for (int y = 0; y < m_tiles.rows() - 1; y++)
				m_tiles(x, y)->copy(*m_tiles(x, y + 1), 0.f, -Tile::TileSize);
		}
		computeMapRange(0, m_tiles.columns(), m_tiles.rows() - 1, m_tiles.rows());
	}
	else if (p_offsetY < 0)
	{
		for (int x = 0; x < m_tiles.columns(); x++)
		{
			for (int y = m_tiles.rows() - 1; y > 0; y--)
				m_tiles(x, y)->copy(*m_tiles(x, y - 1), 0.f, Tile::TileSize);
		}
		computeMapRange(0, m_tiles.columns(), 0, 1);
	}
}

void Map::nextStep(void)
{
	mf_thirdDimension += 2.f;
}

void Map::previousStep(void)
{
	mf_thirdDimension -= 2.f;
}

unsigned int Map::getVerticeCount(void) const
{
	return mn_verticesCount;
}

unsigned int Map::getColumns(void) const
{
	return m_tiles.columns();
}

unsigned int Map::getRows(void) const
{
	return m_tiles.rows();
}

Tile & Map::get(unsigned int column, unsigned int row)
{
	return *m_tiles(column, row);
}

Tile const & Map::get(unsigned int column, unsigned int row) const
{
	return *m_tiles(column, row);
}

