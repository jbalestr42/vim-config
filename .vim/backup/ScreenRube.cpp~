#include "ScreenRube.hpp"
#include "OctoLogger.hpp"

#include <vector>
#include "b2dJson.h"
#include "b2dJsonImage_SFML.h"
#include "QueryCallbacks.h"

//---------------------------------------
//---------------------------------------

ScreenRube::ScreenRube(void) :
	AScreenBase(),
	m_filename(""),
	m_world(NULL),
	m_mouseJoint(NULL)
{
}

ScreenRube::~ScreenRube(void)
{
	clear();
}

PanZoomScene & ScreenRube::getPanZoomScene(void)
{
	return m_pan;
}

void ScreenRube::init(void)
{
	std::string filename = "Rube/OctoTest2.json";
	init(filename);
	m_pan.setViewCenter(b2Vec2(0,3));
	m_pan.setViewVerticalSpan(20);

}

void ScreenRube::init(std::string p_filename)
{
	clear();

	m_filename = p_filename;
	b2dJson json;
	std::string errMsg;
	m_world = json.readFromFile(m_filename.c_str(), errMsg);

	//TODO: Images and Json parsing system
	initElement("Rube/walker.json", b2Vec2(10.0f, 10.0f));

	if (!m_world)
	{
		OctoLogger::log("Failed to load scene from " + p_filename + " : " + errMsg);
		//TODO: Clean quit
	}
	m_debugDraw.SetFlags(b2Draw::e_shapeBit);
	m_world->SetDebugDraw(&m_debugDraw);

	OctoLogger::log() << "Loaded scene from " << p_filename;

	afterLoadProcessing(&json);
}

void ScreenRube::initElement(std::string p_filename, b2Vec2 p_pos, float p_angle)
{
	b2dJson json2;
	std::string errMsg;
	m_world = json2.readFromFile(p_filename.c_str(), errMsg, m_world);

	std::vector<b2Body*> bodies;
	json2.getAllBodies(bodies);
	for (int i = 0; i < bodies.size(); i++) {
		b2Body* body = bodies[i];
		body->SetTransform(body->GetPosition() + p_pos, body->GetAngle() + p_angle);
	}
}

void ScreenRube::afterLoadProcessing(b2dJson * p_json)
{
	//load images
	std::vector<b2dJsonImage*> images;
	p_json->getAllImages(images);
	for (int i = 0; i < (int)images.size(); i++) {
		b2dJsonImage_SFML* img = new b2dJsonImage_SFML(images[i]);
		m_images.push_back(img);
	}
	reorderImages();
}

void ScreenRube::clear()
{
	for (int i = 0; i < (int)m_images.size(); i++)
		delete m_images[i];
	m_images.clear();
	if (m_world)
		delete m_world;
	m_world = NULL;
}

// Step the physics world with fixed time step length
void ScreenRube::update(float pf_deltatime)
{
	if (m_world)
		m_world->Step(1/60.0, 8, 3); // (timestep, velocity iteration, position iteration)
	m_pan.applyView();

	for (int i = 0; i < (int)m_images.size(); i++)
		m_images[i]->update(m_pan.worldToPixelDimension(1), m_pan.worldToPixel(b2Vec2(0,0)));

	glEnable(GL_BLEND);
}

void ScreenRube::draw(sf::RenderTarget &p_target, sf::RenderStates p_states) const
{
	if (m_world)
		m_world->DrawDebugData();
	//draw images
	for (int i = 0; i < (int)m_images.size(); i++)
		m_images[i]->render();

	if (m_mouseJoint) {
		b2Vec2 p1 = m_mouseJoint->GetAnchorB();
		b2Vec2 p2 = m_mouseJoint->GetTarget();
		glColor3f(0.8f, 0.8f, 0.8f);
		glBegin(GL_LINES);
		glVertex2f(p1.x, p1.y);
		glVertex2f(p2.x, p2.y);
		glEnd();
	}
}

void ScreenRube::pollEvent(sf::Event p_event)
{
	if (p_event.type == sf::Event::KeyPressed)
		keyDown(p_event.key);
	else if (p_event.type == sf::Event::KeyReleased)
		keyUp(p_event.key);
	else if (p_event.type == sf::Event::MouseButtonPressed)
		mouseDown(p_event.mouseButton);
	else if (p_event.type == sf::Event::MouseButtonReleased)
		mouseUp(p_event.mouseButton);
	else if (p_event.type == sf::Event::MouseMoved)
		mouseMove(p_event.mouseMove);
	else if (p_event.type == sf::Event::MouseWheelMoved)
		m_pan.mouseWheel(p_event.mouseWheel);
}

// Reload the scene if use has hit the R key
void ScreenRube::keyDown(sf::Event::KeyEvent p_keyEvent)
{
	switch (p_keyEvent.code) {
		case sf::Keyboard::R:
			{
				init(m_filename);
			}
			break;
		default:;
	}
}

void ScreenRube::keyUp(sf::Event::KeyEvent keyEvent)
{
}

// Here we make a mouse joint to drag dynamic bodies around
void ScreenRube::mouseDown(sf::Event::MouseButtonEvent p_mouseButtonEvent)
{
	m_pan.mouseDown(p_mouseButtonEvent);

	if ( ! m_world )
		return;
	if (m_mouseJoint != NULL)
		return;

	// Make a small box.
	b2AABB aabb;
	b2Vec2 d;
	d.Set(0.001f, 0.001f);
	aabb.lowerBound = m_pan.m_mousePosWorld - d;
	aabb.upperBound = m_pan.m_mousePosWorld + d;

	// Query the world for overlapping shapes.
	MouseDownQueryCallback callback(m_pan.m_mousePosWorld);
	m_world->QueryAABB(&callback, aabb);

	if (callback.m_fixture)
	{
		b2BodyDef bd;
		bd.type = b2_staticBody;
		b2Body* groundBody = m_world->CreateBody(&bd);

		b2Body* body = callback.m_fixture->GetBody();
		b2MouseJointDef md;
		md.bodyA = groundBody;
		md.bodyB = body;
		md.target = m_pan.m_mousePosWorld;
		md.maxForce = 1000.0f * body->GetMass();
		m_mouseJoint = (b2MouseJoint*)m_world->CreateJoint(&md);
		body->SetAwake(true);
	}
}

// Get rid of the mouse joint if we have one
void ScreenRube::mouseUp(sf::Event::MouseButtonEvent p_mouseButtonEvent)
{
	//cout << "mouseUp" << endl; fflush(stdout);
	m_pan.mouseUp(p_mouseButtonEvent);

	if (m_mouseJoint)
	{
		m_world->DestroyBody(m_mouseJoint->GetBodyA()); //this will destroy the joint too
		m_mouseJoint = NULL;
	}
}

// Update the mouse joint target position, if we have one
void ScreenRube::mouseMove(sf::Event::MouseMoveEvent p_mouseMoveEvent)
{
	//cout << "mouseMove" << endl; fflush(stdout);
	m_pan.mouseMove(p_mouseMoveEvent);

	if (m_mouseJoint)
	{
		m_mouseJoint->SetTarget(m_pan.m_mousePosWorld);
	}
}

bool compareImagesByRenderOrder_ascending(const b2dJsonImage_SFML* a, const b2dJsonImage_SFML* b)
{
	return a->renderOrder < b->renderOrder;
}

void ScreenRube::reorderImages()
{
	std::sort(m_images.begin(), m_images.end(), compareImagesByRenderOrder_ascending);
}

// Removes the given image from the scene
void ScreenRube::removeImage(b2dJsonImage_SFML * p_image)
{
	for (int i = m_images.size() - 1; i >= 0; i--) {
		b2dJsonImage_SFML *img = m_images[i];
		if (img == p_image) {
			m_images.erase( m_images.begin() + i );
			delete img;
		}
	}
}

// Remove one body from the scene, along with any images attached to it
void ScreenRube::removeBody(b2Body * p_body)
{
	if (!p_body)
		return;

	//destroy the body in the physics world
	m_world->DestroyBody(p_body);

	//remove all images that were attached to the body we just deleted
	for (int i = m_images.size() - 1; i >= 0; i--) {
		b2dJsonImage_SFML *img = m_images[i];
		if (img->body == p_body) {
			m_images.erase(m_images.begin() + i);
			delete img;
		}
	}
}

